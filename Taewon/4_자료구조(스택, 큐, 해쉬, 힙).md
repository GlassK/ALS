## 가장 큰 수

```python
#ref
import sys
sys.stdin = open("input.txt", "rt")
num, m = map(int, input().split())
num = list(map(int, str(num)))
stack = []
for x in num:
    while stack and m > 0 and stack[-1] < x:
        stack.pop()
        m -= 1
    stack.append(x)
if m != 0:
    stack = stack[:-m]
res = ''.join(map(str, stack))
print(res)
```

- 각 숫자에 대해서 그 숫자보다 작은 숫자는 제거해야 한다 + 제거해야 할 숫자 개수만큼만 제거한다
  
- 만약 모든 수에 대해 반복이 끝났는데도 제거할 개수만큼 제거하지 않으면 그 개수만큼 끝 원소 제거
  
- 스택: 들어가고 나오는 입구가 한 곳이고 LIFO(Last In First Out)로 나중에 들어간 게 먼저 나온다

  - 파이썬에는 리스트를 이용하여 구현한다(`append`, `pop` 등)

- 결과를 출력할 때는 `for x in stack: print(x, end=' ')`로 출력해도 무관함

  

## 쇠막대기

```python
#ref
import sys
sys.stdin = open("input.txt", "r")
s = input()
stack = []
cnt = 0
for i in range(len(s)):
    if s[i] == '(':
        stack.append(s[i])
    else:
        stack.pop()
        if s[i-1] == '(':
            cnt += len(stack)
        else:
            cnt += 1
print(cnt)
```

- 스택 문제라고 파악되면 stack 리스트를 생성한 후 스택 구조를 이용해서 어떻게 해결할지 충분히 고민하기
- '('일 때는 스택에 차례대로 넣고 ')'일 때는 스택에서 그 쌍이 되는 ')'를 제거한다
  - ') '직전이 '('이면 그때까지의 스택의 길이만큼 cnt에 더한다 (레이저로 자름)
  - 그렇지 않으면 1만 더한다(한 쇠막대기가 끝난 것임)

- 입력을 받을 때 sys.stdin.readline()으로 받으면 마지막에 개행 문자('\n')가 포함된다!

  - input() 내장 함수는 입력 받은 값의 개행 문자를 삭제 시켜서 리턴한다

  - sys.stdin.readline()은 입력 크기에 제한을 두어 한번에 읽어들일 문자의 수를 지정할 수도 있다. 

    ```python
    num = sys.stdin.readline(2) # 입력 : 1234
    print(num) # 결과 : 12
    ```

  - [input과 sys.stdin.readline()의 차이](https://velog.io/@gouz7514/%ED%8C%8C%EC%9D%B4%EC%8D%AC-input-vs-sys.stdin.readline)



## 후위표기식 만들기

```python
#ref
import sys
sys.stdin = open("input.txt", "r")
a = input()
stack = []
res = ''
for x in a:
    if x.isdecimal():
        res += x
    else:
        if x == '(':
            stack.append(x)
        elif x == '*' or x == '/':
            while stack and (stack[-1] == '*' or stack[-1] == '/'):
                res += stack.pop()
            stack.append(x)
        elif x == '+' or x == '-':
            while stack and stack[-1] != '(':
                res += stack.pop()
            stack.append(x)
        elif x == ')':
            while stack and stack[-1] != '(':
                res += stack.pop()
            stack.pop()
while stack:
    res += stack.pop()
print(res)
```

- 컴퓨터에서는 중위표기식을 처리하기 어렵다(연산자의 우선순위까지 고려해야 함)

  - 그래서 중위식을 후위표기식으로 바꿔서 표현함
  - 한 연산자에 대하여 그 앞의 두 숫자가 피연산자가 된다

- +와 -의 경우 연산 우선순위가 가장 낮다. 

  - 우선순위: `(`, `)`  <  `*`, `/`  <  `+`, `-`

- 숫자(피연산자)는 `res`(출력할 값)에 바로 저장한다

- **연산자는 스택에 넣는다.**

  - 만약 원래 들어가 있는 연산자의 우선순위와 새로 들어가는 연산자의 우선순위를 비교했을 때

    - 새로 들어가는 연산자의 우선순위가 더 같거나 높을 경우 원래 들어가 있는 연산자를 `res`로 보내고 스택에 들어간다  **`res += stack.pop()`**
    - 원래 들어가 있는 연산자의 우선순위가 더 같거나 높을 경우 그냥 스택에 들어간다

    *while문*을 통해 비교를 반복한다!

  - `)`의 경우 `(` 까지의 모든 연산자를 `res`에 추가해야 한다 + `(`는 스택에서 삭제

  - `while stack and stack[-1] != '('` : 괄호 안에 있는 경우를 의미

- 연산이 끝났는데도 피연산자가 스택에 남아있는 경우 차례로 `res`에 추가한다



## 후위식 연산

```python
#ref
import sys
sys.stdin=open("input.txt", "r")
a=input()
stack=[]
for x in a:
    if x.isdecimal():
        stack.append(int(x))
    else:
        if x=='+':
            n1=stack.pop()
            n2=stack.pop()
            stack.append(n2+n1)
        elif x=='-':
            n1=stack.pop()
            n2=stack.pop()
            stack.append(n2-n1)
        elif x=='*':
            n1=stack.pop()
            n2=stack.pop()
            stack.append(n2*n1)
        elif x=='/':
            n1=stack.pop()
            n2=stack.pop()
            stack.append(n2/n1)
print(stack[0])
```

- 혼자 해결했을 때와 코드 동일함!
  - 다만 pop한 값을 저장한 후에 더해서 append하는 걸 한번에 했다
- 후위표기식과 후위식 연산 간 차이에 주목