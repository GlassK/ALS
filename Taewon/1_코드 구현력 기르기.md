## K번째 약수

```python
import sys

n, k = map(int, sys.stdin.readline().split())
list = []

for i in range(1, n+1):
    if n % i == 0:
        list.append(i)
else:
    print(list[k-1]) if len(list) >= k else print(-1)
```

```python
#ref
import sys
sys.stdin = open("input.txt", "r")
n, k = map(int, input().split())
cnt = 0
for i in range(1, n+1):
    if n % i == 0:
        cnt += 1
    if cnt == k:
        print(i)
        break
else:
    print(-1)
```

- 항상 모든 약수를 구할 필요 없이 오름차순으로 약수의 개수를 세는 cnt를 이용해서 cnt가 k가 될 때까지만 약수를 구하면 답을 찾을 수 있다.



## K번째 수

```python
import sys

t = int(sys.stdin.readline())

for i in range(1, t + 1):
    n, s, e, k = map(int, sys.stdin.readline().split())
    n_list = list(map(int, sys.stdin.readline().split()))
    n_sort_list = n_list[s-1:e]
    n_sort_list.sort()
    print(f'#{i} {n_sort_list[k-1]}')
```

```python
#ref
import sys
sys.stdin = open("input.txt", "r")
T = int(input())
for t in range(T):
    n, s, e, k = map(int, input().split())
    a = list(map(int, input().split()))
    a = a[s-1:e]
    a.sort()
    print("#%d %d" % (t+1, a[k-1]))
```

- `list.sort()` : 오름차순 정렬. 동시에 새로운 리스트에 할당할 수 없음

- 굳이 새로운 리스트를 선언하고 할당할 필요 없이 최초의 리스트를 업데이트해도 된다



## K번째 큰 수

```python
#ref
import sys
sys.stdin = open("input.txt", "r")
n, k = map(int, input().split())
a = list(map(int, input().split()))
res = set()
for i in range(n):
    for j in range(i+1, n):
        for m in range(j+1, n):
            res.add(a[i]+a[j]+a[m])
res = list(res)
res.sort(reverse=True)
print(res[k-1])
```

- 문제는 이해했는데 카드값 리스트에서 세 개씩 더한 값을 리스트에 저장하는 방법을 모르겠다
  - 삼중 for문을 이용하면 된다 (중복을 방지하기 위해 `i+1`, `j+1`로 인덱스 지정)
  - 중복을 제거하기 위해 **set** 자료구조 이용
    - set에는 sort하는 함수가 없으므로 리스트로 바꾼다
- 다시 도전했을 때 삼중 for문에서 k를 또 사용해서 계속 답이 제대로 안 나왔었다..! 조심하기



## 대표값

```python
import sys
n = int(sys.stdin.readline())
score = list(map(int, sys.stdin.readline().split()))
average = sum(score) / n
score_min = abs(average - score[0])

for i in range(len(score)):
    if abs(average - score[i]) < score_min:
        score_min = abs(average - score[i])
        num = i + 1

print(f'{int(round(average, 0))} {num}')
```

- 평균과 가장 가까운 점수가 여러 개일 경우 점수가 높은 학생의 번호를 답으로 해야 함 (구현 실패)
- 나머지 조건은 구현함

```python
#ref
import sys
sys.stdin=open("input.txt", "r")
n = int(input())
a = list(map(int, input().split()))
ave = sum(a)/n
ave= ave + 0.5
ave= int(ave)
min = 2147000000
for idx, x in enumerate(a):
    tmp = abs(x-ave)
    if tmp < min:
        min = tmp
        score = x
        res = idx+1
    elif tmp == min:
        if x > score:
            score = x
            res = idx+1
print(ave, res)
```

- min 초기화 시 정수형에서 취할 수 있는 가장 큰 값인 2147000000으로 초기화하는 걸 권장

- `enumerate`로 리스트 원소의 번호와 값을 함께 가져오는 걸 생각해내지 못 함

  - 평균과 가장 가까운 점수가 여러 개일 경우 점수가 높은 학생의 번호를 답으로 해야 하므로 점수도 변수에 저장해둔다(`score`) 
  - 높은 점수를 가진 학생이 여러 명일 경우 고려(`elif tmp==min`)
    - 점수가 크지 않는 한 `idx`를 유지한다 (`>`가 아니라 `>=`이면 idx도 바뀜)

- `round()`: 반올림 함수

  - round_half_even 방식을 택한다. 즉, 정확히 half 지점일 때 짝수 쪽으로 내리거나 올린다

    ex. a = 4.500일 때 print(round(a))의 결과는 5가 아니라 4(짝수)

    ex. b = 5.500일 때 print(round(b))의 결과는 6(짝수)

  - 우리가 아는 반올림을 하기 위해서는 (소수 첫째 자리에서 반올림할 경우) round() 대신 **값에 0.5 를 더한 후 int형으로 형변환**하자!



## 정다면체

```python
import sys
from collections import Counter

n, m = map(int, sys.stdin.readline().split())
sum_list = []
max_list = []

for i in range(1, n+1):
    for j in range(1, m+1):
        sum_list.append(i + j)

count = Counter(sum_list).most_common()
max_sum = count[0][1]
for num in count:
    if num[1] == max_sum:
        max_list.append(num[0])

for i in max_list:
    print(i, end=' ')
```

- 리스트의 아이템에 대한 빈도를 조사하기 위해 collections 모듈의 Counter 클래스 이용
  - `Counter(리스트).most_common()`: 데이터가 많은 순으로 정렬

```python
#ref
import sys
sys.stdin=open("input.txt", "r")
n, m=map(int, input().split())
cnt=[0]*(n+m+3)
max=0
for i in range(1, n+1):
    for j in range(1, m+1):
        cnt[i+j]=cnt[i+j]+1

for i in range(n+m+1):
    if cnt[i]>max:
        max=cnt[i]
    
for i in range(n+m+1):
    if cnt[i]==max:
        print(i, end=' ')
```

- `cnt=[0]*(n+m+3)`: 합이 나올 수 있는 경우의 수만큼 크기를 갖는 리스트를 선언하고 0으로 초기화한다
- 먼저 최대 빈도를 알아낸 후 최대 빈도에 해당하는 숫자 출력

