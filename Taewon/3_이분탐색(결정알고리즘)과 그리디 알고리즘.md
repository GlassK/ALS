## 이분 검색

```python
import sys

n, m = map(int, sys.stdin.readline().split())
num = list(map(int, sys.stdin.readline().split()))
num.sort()
start = 0
end = n - 1

while True:
    mid = num[(start+end)//2]
    if mid == m:
        print(num.index(m) + 1)
        break
    elif mid < m:
        start = num.index(mid)
    else:
        end = num.index(mid)
```

- 코드는 바로 짰는데 start와 end를 인덱스가 아닌 값으로 초기화하는 실수 반복
- `while True`로 하면 만약 숫자 중 찾고자 하는 값이 없을 경우를 처리하지 못함

```python
#ref
import sys
sys.stdin = open("input.txt", "r")
n, m = map(int, input().split())
a = list(map(int, input().split()))
a.sort()
lt = 0
rt = n-1
while lt <= rt:
    mid = (lt+rt)//2
    if a[mid] == m:
        print(mid+1)
        break
    elif a[mid] > m:
        rt = mid-1
    else:
        lt = mid+1
```

- `lt`, `rt`: 포인터 변수 지정 (검색하고자 하는 범위 설정)
- 값으로 바로 접근하지 않고 인덱스로만 찾은 후 값에 접근하면 된다
  - 첫번째 코드와 달리 중복으로 검색하는 경우가 없다
- 최대 연산 횟수 (N은 숫자의 개수)

$$
log_2 N
$$



## 랜선자르기(결정알고리즘)

```python
#ref
import sys
sys.stdin = open("input.txt", "r")


def Count(len):
    cnt = 0
    for x in Line:
        cnt += (x//len)
    return cnt


k, n = map(int, input().split())
Line = []
res = 0
largest = 0
for i in range(k):
    tmp = int(input())
    Line.append(tmp)
    largest = max(largest, tmp)
lt = 1
rt = largest
while lt <= rt:
    mid = (lt+rt)//2
    if Count(mid) >= n:
        res = mid
        lt = mid+1
    else:
        rt = mid-1
print(res)
```

- 입력한 길이 값 중 최댓값을 구한다. 입력한 길이 값을 `mid`(`lt`와 `rt`의 중간 값)로 나눈 값(Count 함수)을 기준으로 이분 검색을 실시한다
- 이분 검색은 결정 알고리즘에 사용된다.
- 결정 알고리즘 문제의 특징
  - 답의 범위를 예상할 수 있다
  - 예상한 답의 범위 내에서 이분 검색을 이용한다
    - 답이 될 수 있는지 함수를 통해 확인한다
    - 답이 될 수 없다면 범위를 절반으로 줄여서 최적의 답을 다시 탐색한다 

- 랜선 길이의 범위는 1~802(k개의 랜선 중 가장 긴 것의 길이)
  - 범위 중 중간 값을 이용했을 때 랜선이 N개 이상 나오는지 확인
  - 답이 나오지 않으면 1~(중간값-1) 내에서 다시 탐색한다
- 답이 나온 경우 우선 `res`에 저장한 후 그 값보다 큰 경우 이상 범위에서 다시 탐색한다 (최적)

- `Count` 함수에서 `Line` 리스트를 사용하는데 함수를 정의하는 시점과 호출하는 시점이 다르고, 호출하는 시점에는 `Line` 리스트가 이미 만들어져 있으므로 에러가 나지 않는다



## 뮤직비디오(결정 알고리즘)

```python
#ref
import sys
sys.stdin = open("input.txt", "r")


def Count(capacity):
    cnt = 1
    sum = 0
    for x in Music:
        if sum+x > capacity:
            cnt += 1
            sum = x
        else:
            sum += x
    return cnt


n, m = map(int, input().split())
Music = list(map(int, input().split()))
maxx = max(Music)
lt = 1
rt = sum(Music)
res = 0
while lt <= rt:
    mid = (lt+rt)//2
    if mid >= maxx and Count(mid) <= m:
        res = mid
        rt = mid-1
    else:
        lt = mid+1
print(res)
```

- 최소 용량(lt)은 1, 최대 용량(rt)은 곡 길이의 총합

- 용량 크기가 최대 길이보다는 크면서 Count의 결과가 DVD 개수보다는 같거나 작을 경우 계속해서 최적을 구한다
- `Count()` : 주어진 용량에 리스트 값을 담을 때 필요한 DVD의 개수 리턴
  - 수를 더해봤을 때 용량 크기보다 클 경우 마지막에 더한 값을 유지하고 count 1 증가
  - 용량 크기와 같거나 작을 경우 계속 기존 값에 더함



## 마굿간 정하기(결정 알고리즘)

```python
#ref
import sys
sys.stdin = open("input.txt", "r")


def Count(len):
    cnt = 1
    ep = Line[0]
    for i in range(1, n):
        if Line[i]-ep >= len:
            cnt += 1
            ep = Line[i]
    return cnt


n, c = map(int, input().split())
Line = []
for _ in range(n):
    tmp = int(input())
    Line.append(tmp)
Line.sort()
lt = 1
rt = Line[n-1]
while lt <= rt:
    mid = (lt+rt)//2
    if Count(mid) >= c:
        res = mid
        lt = mid+1
    else:
        rt = mid-1

print(res)
```

- **Count 함수의 역할과 구성을 생각해 내는 게 핵심** (결정 알고리즘 자체를 구현하는 코드 패턴은 고정적이다)
- `Count()`: 매개변수 `len`은 말들 간의 최소 거리
  - `ep = Line[0]`: 첫 번째 칸에는 무조건 말 넣음
  - `len`에 따라 배치할 수 있는 말의 수를 `cnt`로 확인한다
    - `cnt`가 `c`보다 작으면 `rt`를 `mid-1`로 바꾼 후 다시 탐색
    - `cnt`가 `c`보다 크거나 같으면 일단 `res`에 저장한 후 최적 찾기

