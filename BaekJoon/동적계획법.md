### #1463

- 정수 X에 사용할 수 있는 연산
  - X가 3으로 나눠 떨어지면 3으로 나눈다
  - X가 2로 나눠 떨어지면 2로 나눈다
  - 1을 뺀다
- 정수 N에 대해 연산 세 개를 적절히 사용해서 1 만들기
  - 10의 경우 10 -> 9 -> 3 -> 1로 3번 만에 만들 수 있다
- 출력: 연산을 사용하는 횟수의 최솟값

```python
import sys
n = int(sys.stdin.readline())
dp = [0 for _ in range(n + 1)]
for i in range(2, n + 1):
    if i % 2 == 0:
        dp[i] = dp[i//2] + 1
    elif i % 3 == 0:
        dp[i] = dp[i//3] + 1
    else:
        dp[i] = dp[i-1] + 1
print(dp[n])
```

- 크기가 N인 배열을 선언하고 0으로 초기화한다.
  - 인덱스 0과 1의 값은 0
  - 인덱스 2부터 N까지 값을 채운 후 최소 연산 횟수를 출력한다
- x가 2의 배수이면 (x/2의 최소 연산 횟수) + 1
- x가 3의 배수이면 (x/3의 최소 연산 횟수) + 1
- x가 2나 3의 배수가 아니면 (x-1의 최소 연산 횟수) + 1
- n이 10일 때 고려해야 함



### #11726

- 2×n 크기의 직사각형을 1×2, 2×1 타일로 채우는 방법의 수 구하기
- 출력: 방법의 수를 10007로 나눈 나머지

```python
import sys

n = int(sys.stdin.readline())
dp = [0 for _ in range(1001)]
dp[1] = 1
dp[2] = 2

for i in range(3, n+1):
    dp[i] = dp[i-1] + dp[i-2] % 10007
print(dp[n] % 10007)
```

- dp 리스트 사이즈를 1000으로 정하지 않으면 런타임 오류(인덱스 에러) 발생
  - n의 범위는 1 이상 1000 이하
- 출력하는 값뿐만 아니라 dp에 저장하는 모든 값을 10007로 나눈 나머지로 저장하면 리스트에 더 작은 값을 각각 저장할 수 있다 (답에는 영향 미치지 않음)



### #11727

```Python

```

