### #10430 나머지

```python
if __name__ == "__main__":
    a, b, c = map(int, input().split())
    print((a+b) % c)
    print(((a % c)+(b % c)) % c)
    print((a*b) % c)
    print(((a % c)*(b % c)) % c)
```



### #2609 최대공약수와 최소공배수

```python
def gcd(a, b):
    c, d = max(a, b), min(a, b)
    temp = 1
    while temp > 0:
        temp = c % d
        c, d = d, temp
    return c


def lcm(a, b):
    return int(a*b / gcd(a, b))


if __name__ == "__main__":
    a, b = map(int, input().split())
    print(gcd(a, b))
    print(lcm(a, b))
```

- 유클리드 호제법
  - a와 b 중 큰 수를 c, 작은 수를 d라고 했을 때 c를 d로 나눈 나머지를 temp라고하자. c와 d의 최대공약수는 d와 temp의 최대공약수와 같다. temp가 0이 될 때까지 반복적으로 c와 d를 d와 temp로 업데이트하면 최종적으로 c가 최대공약수이다.
  - 최소공배수는 a와 b의 곱을 a와 b의 최대공약수로 나눈 값이다.



### #1934 최소공배수

```python
def gcd(a, b):
    c, d = max(a, b), min(a, b)
    temp = 1
    while temp > 0:
        temp = c % d
        c, d = d, temp
    return c


def lcm(a, b):
    return int(a*b / gcd(a, b))


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        a, b = map(int, input().split())
        print(lcm(a, b))
```



### #1850 최대공약수

```python
# ref
def gcd(a, b):
    c, d = max(a, b), min(a, b)
    temp = 1
    while temp > 0:
        temp = c % d
        c, d = d, temp
    return c


if __name__ == "__main__":
    a, b = map(int, input().split())
    print('1'*gcd(a, b))
```

[참고](https://claude-u.tistory.com/404)

- a와 b개의 1로만 이뤄져 있는 수 그 자체로 최대공약수를 구하면 메모리 초과 에러 발생
- 직접 구하지 않고 두 수의 1의 개수(a와 b)끼리의 최대공약수만 구하면 된다!



### #9613 GCD 합

```python
def gcd(a, b):
    c, d = max(a, b), min(a, b)
    temp = 1
    while temp > 0:
        temp = c % d
        c, d = d, temp
    return c


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        nums = list(map(int, input().split()))
        total = 0
        n = nums[0]
        for i in range(1, n):
            for j in range(i+1, n+1):
                total += gcd(nums[i], nums[j])
        print(total)
```

